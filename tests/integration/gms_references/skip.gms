Set i(*) "condensers-columns";
Set j(*) "reboilers";
Set hu(*) "hot utilities";
Set cu(*) "cold utilities";
Set n(*) "index";
Set m(*) "intermediates";
Set pm(i,m) "products";
Set fm(i,m) "feeds";
Alias(i,ip);
Alias(j,jp);
Set zlead(i) "leading columns in superstructure";
Set zcrhx(i,j) "condenser to reboiler allowable matches";
Set zlim(i,j) "direction of heat integration";
Set zcr(i,j) "reboiler-condenser pairs";
Parameter spltfrc(i,m) "split fraction of distillation columns";
Parameter tcmin(i) "minimum condenser temperatures";
Parameter fc(i) "fixed charge for distillation columns";
Parameter vc(i) "variable charge for distillation columns";
Parameter thu(hu) "hot utility temperatures";
Parameter costhu(hu) "hot utility cost coefficients";
Parameter kf(i,n) "coeff. for heat duty temperature fits";
Parameter af(i,n) "coeff. for column temperature fits";
Parameter totflow "total flow to superstructure";
Parameter fchx "fixed charge for heat exchangers scaled";
Parameter vchx "variable charge for heat exchangers scaled";
Parameter htc "overall heat transfer coefficient";
Parameter dtmin "minimum temperature approach";
Parameter tcin "inlet temperature of cold water";
Parameter tcout "outlet temperature of cold water";
Parameter costcw "cooling water cost coefficient";
Parameter beta "income tax correction factor";
Parameter alpha "one over payout time factor in years";
Parameter u "large number for logical constraints";
Parameter uint "upper bound for integer logical";
positive Variable f(i) "flowrates to columns";
positive Variable qr(j) "reboiler duties for column with reboiler j";
positive Variable qc(i) "condenser duties for column i";
positive Variable qcr(i,j) "heat integration heat transfer";
positive Variable qhu(hu,j) "hot utility heat transfer";
positive Variable qcu(i,cu) "cold utility heat transfer";
positive Variable tc(i) "condenser temperature for column with cond. i";
positive Variable tr(j) "reboiler temperature for column with reb. j";
positive Variable lmtd(i) "lmtd for cooling water exchanges";
positive Variable sl1(i) "artificial slack variable for lmtd equalities";
positive Variable sl2(i) "artificial slack variable for lmtd equalities";
positive Variable s1(i) "artificial slack variable for reb-con equalities";
positive Variable s2(i) "artificial slack variable for reb-con equalities";
positive Variable s3(i) "artificial slack variable for duty equalities";
positive Variable s4(i) "artificial slack variable for duty equalities";
binary Variable yhx(i,j) "heat integration matches condenser i reboiler j";
binary Variable yhu(hu,j) "hot utility matches hot utility hu reboiler j";
binary Variable ycu(i,cu) "cold utility matches condenser i cold util cu";
binary Variable ycol(i) "columns in superstructure";
Equation tctrlo(i,j) "prevent division by 0 in the objective";
Equation lmtdlo(i) "prevent division by 0 in the objective";
Equation lmtdsn(i) "nonlinear form of lmtd definition";
Equation tempset(i) "sets temperatures of inactive columns to 0 (milp)";
Equation artrex1(i) "relaxes artificial slack variables (nlp)";
Equation artrex2(i) "relaxes artificial slack variables (nlp)";
Equation material(m) "material balances for each intermediate product";
Equation feed "feed to superstructure";
Equation matlog(i) "material balance logical constraints";
Equation duty(i) "heat duty definition of condenser i";
Equation rebcon(i,j) "equates condenser and reboiler duties";
Equation conheat(i) "condenser heat balances";
Equation rebheat(j) "reboiler heat balances";
Equation dtminlp(j) "minimum temp approach for low pressure steam";
Equation dtminc(i) "minimum temp allowable for each condenser";
Equation trtcdef(i,j) "relates reboiler and condenser temps of columns";
Equation dtmincr(i,j) "minimum temp approach for heat integration";
Equation dtminex(j) "minimum temp approach for exhaust steam";
Equation hxclog(i,j) "logical constraint for heat balances";
Equation hxhulog(hu,j) "logical constraint for heat balances";
Equation hxculog(i,cu) "logical constraint for heat balances";
Equation qcqrlog(i) "logical constraint for con-reb duties";
Equation sequen(m) "restricts superstructure to a single sequence";
Equation lead "sequence control";
Equation limutil(j) "limits columns to have a single hot utility";
Equation hidirect(i,j) "requires a single direction of heat integration";
Equation heat(i) "logical integer constraint";
free Variable skip_objective_variable;
Equation skip_objective;
Model skip / tctrlo,lmtdlo,lmtdsn,tempset,artrex1,artrex2,material,feed,matlog,duty,rebcon,conheat,rebheat,dtminlp,dtminc,trtcdef,dtmincr,dtminex,hxclog,hxhulog,hxculog,qcqrlog,sequen,lead,limutil,hidirect,heat,skip_objective /;
$gdxLoadAll C:\Users\muhammet\Documents\gams_workspace\gamspy\tmp\to_gams\skip_data.gdx
tctrlo(zcrhx(i,j)) .. (((tc(i) - tr(j)) + 1) - ycol(i)) =g= 1;
lmtdlo(i) .. lmtd(i) =g= (2 * ycol(i));
lmtdsn(i) .. lmtd(i) =e= ((((0.6666666666666666 * ( sqrt(((tc(i) - tcin) * (tc(i) - tcout))) )) + (0.16666666666666666 * ((tc(i) - tcin) + (tc(i) - tcout)))) + sl1(i)) - sl2(i));
tempset(i) .. ((tc(i) + lmtd(i)) + sum(zcr(i,j),tr(j))) =l= (u * ycol(i));
artrex1(i) .. ((s1(i) + s2(i)) + sl1(i)) =l= (u * (1 - ycol(i)));
artrex2(i) .. ((s3(i) + s4(i)) + sl2(i)) =l= (u * (1 - ycol(i)));
material(m) .. sum(pm(i,m),(spltfrc(i,m) * f(i))) =e= sum(fm(i,m),f(i));
feed .. sum(zlead(i),f(i)) =e= totflow;
matlog(i) .. f(i) =l= (u * ycol(i));
duty(i) .. qc(i) =e= (((kf(i,"a") + (kf(i,"b") * (tc(i) - tcmin(i)))) + s3(i)) - s4(i));
rebcon(zcr(i,j)) .. qr(j) =e= qc(i);
conheat(i) .. qc(i) =e= (sum(zcrhx(i,j),qcr(i,j)) + sum(cu,qcu(i,cu)));
rebheat(j) .. qr(j) =e= (sum(zcrhx(i,j),qcr(i,j)) + sum(hu,qhu(hu,j)));
dtminlp(j) .. (dtmin - (thu("lp") - tr(j))) =l= 0;
dtminc(i) .. (tcmin(i) - tc(i)) =l= (u * (1 - ycol(i)));
trtcdef(zcr(i,j)) .. tr(j) =e= (((af(i,"a") + (af(i,"b") * (tc(i) - tcmin(i)))) + s1(i)) - s2(i));
dtmincr(zcrhx(i,j)) .. (((tr(j) - tc(i)) - (u * (1 - yhx(i,j)))) + dtmin) =l= 0;
dtminex(j) .. ((dtmin - (thu("ex") - tr(j))) - (u * (1 - yhu("ex",j)))) =l= 0;
hxclog(zcrhx(i,j)) .. qcr(i,j) =l= (u * yhx(i,j));
hxhulog(hu,j) .. qhu(hu,j) =l= (u * yhu(hu,j));
hxculog(i,cu) .. qcu(i,cu) =l= (u * ycu(i,cu));
qcqrlog(i) .. (qc(i) + sum(j $ zcr(i,j),qr(j))) =l= (u * ycol(i));
sequen(m) .. sum(pm(i,m),ycol(i)) =e= sum(fm(i,m),ycol(i));
lead .. sum(zlead(i),ycol(i)) =e= 1;
limutil(j) .. sum(hu,yhu(hu,j)) =l= 1;
hidirect(zlim(i,j)) .. (yhx(i,j) + sum((ip,jp) $ ((ord(ip) eq ord(j)) and (ord(jp) eq ord(i))),yhx(ip,jp))) =l= 1;
heat(i) .. ((sum(zcrhx(i,j),(yhx(i,j) + sum((ip,jp) $ ((ord(ip) eq ord(j)) and (ord(jp) eq ord(i))),yhx(ip,jp)))) + sum((hu,zcr(i,j)),yhu(hu,j))) + sum(cu,ycu(i,cu))) =l= (uint * ycol(i));
skip_objective .. ((alpha * (((sum(i,((fc(i) * ycol(i)) + ((vc(i) * (tc(i) - tcmin(i))) * f(i)))) + sum(zcrhx(i,j),((fchx * yhx(i,j)) + ((vchx / htc) * (qcr(i,j) / (((tc(i) - tr(j)) + 1) - ycol(i))))))) + sum((i,cu),((fchx * ycu(i,cu)) + ((vchx / htc) * (qcu(i,cu) / ((lmtd(i) + 1) - ycol(i))))))) + sum((hu,j),((fchx * yhu(hu,j)) + ((vchx / htc) * (qhu(hu,j) / (thu(hu) - tr(j)))))))) + (beta * (sum((i,cu),(costcw * qcu(i,cu))) + sum((hu,j),(costhu(hu) * qhu(hu,j)))))) =e= skip_objective_variable;
solve skip using MINLP MIN skip_objective_variable;